"""
Sensitive Question Detector
Detects if user is asking for sensitive information like column names, table names, database names
"""
from typing import Tuple
import logging

from langchain_core.prompts import ChatPromptTemplate
from app.llm.gemini_client import gemini_client

logger = logging.getLogger(__name__)


SENSITIVE_QUESTION_DETECTION_PROMPT = ChatPromptTemplate.from_messages([
    ("system", """You are an intelligent security assistant that analyzes user questions to determine if they are requesting sensitive database structure information.

Your task is to:
1. Analyze the user's question carefully
2. Determine if they are asking for sensitive database structure information (schema, table names, column names, database name, etc.)
3. If sensitive, provide a polite, professional rejection message in the user's language
4. If not sensitive, allow the request (user is asking about data content, statistics, or business insights)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸŽ¯ CLASSIFICATION RULES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SENSITIVE (must reject):
- Requests for database schema/structure information
- Requests for table names or list of tables
- Requests for column names or field names
- Requests for database name or connection details
- Requests for technical metadata about database structure
- Any question that asks about "how the database is organized" rather than "what data is in the database"

NOT SENSITIVE (allow):
- Questions about data content (e.g., "How many customers?", "Show top 10 sales")
- Questions asking for statistics or aggregations
- Questions asking for business insights or analysis
- Questions asking to visualize data
- Questions that are clearly about the data itself, not the database structure

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“ OUTPUT FORMAT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Respond with ONLY a JSON object in this exact format (use double braces to escape):
{{
  "is_sensitive": true/false,
  "rejection_message": "Polite, professional message in the user's language explaining why the request cannot be fulfilled. Include examples of what the user CAN ask instead. Only provide this field if is_sensitive is true.",
  "reason": "Brief explanation of why this is sensitive or not sensitive"
}}

IMPORTANT:
- If is_sensitive is true, you MUST provide a rejection_message in the same language as the user's question
- If is_sensitive is false, you can omit rejection_message or set it to null
- The rejection_message should be polite, professional, and helpful
- Include examples of what the user CAN ask instead of their sensitive request

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â“ USER QUESTION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{question}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“¤ YOUR ANALYSIS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Analyze the question and respond with ONLY the JSON object, nothing else:"""),
    ("human", "{question}")
])


class SensitiveQuestionDetector:
    """Detects if a question is asking for sensitive database information"""
    
    def __init__(self):
        self._available = gemini_client.is_available()
        if not self._available:
            logger.warning("Gemini client not available. Sensitive question detection will be skipped.")
    
    def check(self, question: str) -> Tuple[bool, str]:
        """
        Check if question is asking for sensitive information
        
        Uses only Gemini AI for intelligent classification - no hardcoded keywords.
        
        Args:
            question: User's question
        
        Returns:
            (is_sensitive, rejection_message)
            - is_sensitive: True if asking for sensitive info
            - rejection_message: Professional message generated by Gemini explaining why the request is rejected (in user's language)
        """
        if not self._available:
            logger.warning("Gemini client not available. Cannot perform sensitive question detection.")
            return False, ""
        
        try:
            messages = SENSITIVE_QUESTION_DETECTION_PROMPT.format_messages(question=question)
            response = gemini_client.client.invoke(messages)
            
            # Parse JSON response
            import json
            response_text = response.content.strip()
            
            # Extract JSON from response
            response_text = self._extract_json(response_text)
            
            result = json.loads(response_text)
            
            is_sensitive = result.get("is_sensitive", False)
            rejection_message = result.get("rejection_message", "")
            reason = result.get("reason", "")
            
            logger.info(
                f"Sensitive question check (AI-based)",
                extra={
                    "question": question[:100],
                    "is_sensitive": is_sensitive,
                    "reason": reason
                }
            )
            
            if is_sensitive:
                # Use Gemini-generated rejection message
                if rejection_message:
                    return True, rejection_message
                else:
                    # Fallback if Gemini didn't provide message
                    return True, "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø© Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø£Ù…Ù†ÙŠØ©."
            
            return False, ""
            
        except Exception as e:
            logger.error(
                f"Sensitive question detection failed: {e}",
                extra={"question": question[:100]},
                exc_info=True
            )
            # If AI check fails, allow the request (fail open)
            return False, ""
    
    
    def _extract_json(self, text: str) -> str:
        """Extract JSON from text response"""
        import json
        import re
        
        # Try to find JSON in code blocks first
        json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
        if json_match:
            return json_match.group(1)
        
        json_match = re.search(r'```\s*(\{.*?\})\s*```', text, re.DOTALL)
        if json_match:
            return json_match.group(1)
        
        # Try to find JSON object with nested braces support
        # Find the opening brace, then count braces to find the closing one
        start_idx = text.find('{')
        if start_idx != -1:
            brace_count = 0
            for i in range(start_idx, len(text)):
                if text[i] == '{':
                    brace_count += 1
                elif text[i] == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        return text[start_idx:i+1]
        
        # Return as-is and hope it's valid JSON
        return text.strip()


# Global detector instance
sensitive_question_detector = SensitiveQuestionDetector()
